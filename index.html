<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="Java simulation of Charles Babbage's Analytical Engine.">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Analytical Engine</title>

  <link href="https://fonts.googleapis.com/css?family=Lato:300,400|Libre+Baskerville" rel="stylesheet">
  <link rel="stylesheet" href="css/analyticalengine.css">
</head>
<body>
  <div class="container">
    <header>
      <p>Charles&nbsp;Babbage&rsquo;s
      <h1>Analytical Engine</h1>
      <p>A Java Simulation
    </header>

    <p>C<b>harles&nbsp;Bab&shy;bage de&shy;signed</b> (but nev&shy;er built) a
    com&shy;put&shy;ing ma&shy;chine in the mid-1800s, a ma&shy;chine that
    to&shy;day would be called a dig&shy;i&shy;tal com&shy;put&shy;er. On this
    ma&shy;chine mod&shy;el, Ada&nbsp;Lovelace de&shy;signed the first
    com&shy;put&shy;er pro&shy;gram. Babbage&rsquo;s ini&shy;tial
    de&shy;scrip&shy;tions of the ma&shy;chine pre&shy;date Alan&nbsp;Turing's
    mod&shy;el of a gen&shy;er&shy;al pur&shy;pose com&shy;put&shy;er by about
    a hun&shy;dred years. This Java sim&shy;u&shy;la&shy;tion of the
    An&shy;a&shy;lyt&shy;i&shy;cal En&shy;gine will help to pre&shy;serve the
    lega&shy;cy of these pi&shy;o&shy;neers of com&shy;put&shy;ing.

    <nav>
      <h2>Contents</h2>
      <ul>
        <li><a href="#hardware">Hardware overview</a></li>
        <li><a href="#preparing">Preparing the simulator</a></li>
        <li><a href="#programming">Programming the Engine</a></li>
        <li><a href="#programmatic-access">Programmatic access to the simulator</a></li>
        <li><a href="#copyright">Copyright license</a></li>
      </ul>
    </nav>

    <section id="hardware">
      <h2>Hardware overview</h2>

      <aside>
        <p>For more in&shy;for&shy;ma&shy;tion on the
        ter&shy;mi&shy;nol&shy;o&shy;gy,
        see <a href="http://www.fourmilab.ch/babbage/glossary.html">this
        glos&shy;sary</a>.
      </aside>

      <p>The An&shy;a&shy;lyt&shy;i&shy;cal En&shy;gine ma&shy;chin&shy;ery is
      es&shy;sen&shy;tial&shy;ly the same as that of a (sim&shy;ple) mod&shy;ern
      dig&shy;i&shy;tal com&shy;put&shy;er. Here is a brief
      de&shy;scrip&shy;tion of the hard&shy;ware in&shy;clud&shy;ing both
      the old and new ter&shy;mi&shy;nolo&shy;gies.

      <p>Each in&shy;struc&shy;tion for the ma&shy;chine comes on
      a <dfn>card</dfn> with holes punched in it to in&shy;di&shy;cate which
      in&shy;struc&shy;tion it rep&shy;re&shy;sents (that is, its
      &ldquo;op&shy;code&rdquo;). A pro&shy;gram is pro&shy;vid&shy;ed as a
      se&shy;quence of card&shy;s.

      <p>The ran&shy;dom ac&shy;cess mem&shy;o&shy;ry of the ma&shy;chine is
      called the <dfn>&shy;s&shy;tore</dfn> and the arith&shy;metic log&shy;ic
      unit is called the <dfn>mil&shy;l</dfn>. The mill per&shy;forms
      arith&shy;metic op&shy;er&shy;a&shy;tions on in&shy;te&shy;gers, each of
      which is stored in a reg&shy;is&shy;ter called an <dfn>ax&shy;is</dfn>
      (plur&shy;al <dfn>ax&shy;es</dfn>). In&shy;te&shy;gers read from
      mem&shy;o&shy;ry are stored in <dfn>ingress ax&shy;es</dfn> and the
      re&shy;sult of arith&shy;metic op&shy;er&shy;a&shy;tions are stored
      in <dfn>egress ax&shy;es</dfn>. The <dfn>run-up lev&shy;er</dfn> is a
      flag that is set when an arith&shy;metic op&shy;er&shy;a&shy;tion
      caus&shy;es an in&shy;te&shy;ger over&shy;flow.

      <p>The ma&shy;chine is con&shy;trolled by
      an <dfn>at&shy;ten&shy;dan&shy;t</dfn> who loads pro&shy;gram&shy;s,
      starts and op&shy;er&shy;ates the ma&shy;chine while the pro&shy;gram
      ex&shy;e&shy;cutes, and pro&shy;vides a fi&shy;nal re&shy;port
      show&shy;ing the out&shy;put of the ma&shy;chine. The ma&shy;chine can
      pro&shy;duce tex&shy;tu&shy;al out&shy;put via a print&shy;er as well as
      graph&shy;i&shy;cal out&shy;put via a <dfn>curve draw&shy;ing
      ap&shy;pa&shy;ra&shy;tus</dfn>, a de&shy;vice we would call a
      plot&shy;ter.
    </section>

    <section id="preparing">
      <h2>Preparing the simulator</h2>

      <p>The source code for the An&shy;a&shy;lyt&shy;i&shy;cal En&shy;gine
      sim&shy;u&shy;la&shy;tor is avail&shy;able
      from <a href="//github.com/jfinkels/analyticalengine">GitHub</a>.

      <pre class="command-line"><span class="command">git clone https://github.com/jfinkels/analyticalengine</span></pre>

      <p>This project uses <a href="//maven.apache.org/">Maven</a> for build
      man&shy;age&shy;ment and re&shy;quires Java 1.8 to com&shy;pile.

      <p>To cre&shy;ate a shell script that runs the sim&shy;u&shy;la&shy;tor,
      run

      <pre class="command-line"><span class="command">mvn package appassembler:assemble</span></pre>

      <p>This pro&shy;duces a script that ex&shy;e&shy;cutes the
      sim&shy;u&shy;la&shy;tor
      at <code>target/appassembler/bin/analyticalengine</code>. An
      An&shy;a&shy;lyt&shy;i&shy;cal En&shy;gine pro&shy;gram stored in a file
      named <code>myprogram.ae</code>, for ex&shy;am&shy;ple, can then be
      ex&shy;e&shy;cut&shy;ed via

      <pre class="command-line"><span class="command">target/appassembler/bin/analyticalengine myprogram.ae</span></pre>
    </section>

    <section id="programming">
      <h2>Programming the Engine</h2>

      <aside>
        <p>For more in&shy;for&shy;ma&shy;tion on the in&shy;struc&shy;tion set
        and how to write pro&shy;grams for this ma&shy;chine, see the
        <a href="http://www.fourmilab.ch/babbage/cards.html">card
        ref&shy;er&shy;ence</a>.
      </aside>

      <p>The pro&shy;gram&shy;ming lan&shy;guage for this ma&shy;chine is
      ar&shy;cane, but rel&shy;a&shy;tive&shy;ly sim&shy;i&shy;lar to
      mod&shy;ern ma&shy;chine lan&shy;guages. For the pur&shy;pos&shy;es of
      this sim&shy;u&shy;la&shy;tor, an An&shy;a&shy;lyt&shy;i&shy;cal
      En&shy;gine pro&shy;gram is a text file in which each line
      rep&shy;re&shy;sents a card.

      <p>To load a num&shy;ber into the store, use the <code>N</code> card.

      <div class="example">
        <p>Store the num&shy;ber 123 in mem&shy;o&shy;ry lo&shy;ca&shy;tion 1.
        <pre class="ae-code"><span class="card">N1 123</span></pre>
      </div>

      <p>Blank lines, lines beginning with a period, and lines beginning with
      spaces are treated as comment cards.
      <!-- A period after another instruction indicates a comment. -->

      <div class="example">
        <p>In this example there are five comment cards, three of which are
        blank.
        <pre>
<span class="comment">   This program loads two numbers into the store.</span>
<span class="card"></span>
<span class="card">N1 123</span>
<span class="card"></span>
<span class="comment">. This is another comment.</span>
<span class="card"></span>
<span class="card">N2 456</span>
</pre>
      </div>

      <p>Arithmetic operations are automatically executed once the two operands
      are loaded from memory into the ingress axes. The result of the operation
      is automatically extracted from the egress axis and stored in a memory
      location indicated by a store card.

      <div class="example">
        <p>Add two numbers from memory locations 1 and 2 and store the
        result in memory location 3.
        <pre>
<span class="card">N1 123</span>
<span class="card">N2 456</span>
<span class="comment"></span>
<span class="card">+</span>
<span class="card">L1</span>
<span class="card">L2</span>
<span class="card">S3</span></pre>
      </div>

      <p>Division can be performed on a dividend of "double width" by loading
      the lower-order digits of the dividend in the first main ingress axis and
      the higher-order digits of the dividend into the "prime" ingress
      axis. The prime axis must be loaded after the main axis.

      <p>The quotient of a division can be accessed from the prime egress axis,
      and the remainder from the main egress axis. If the quotient is too
      large for the main axis, the run-up lever is set, and the quotient and
      remainder will be set to 0.

      <div class="example">
        <p>Compute 10<sup>50</sup> + 1 divided by two. By default, each axis
        can store a decimal number of fifty digits, so loading 1 into the lower
        order ingress axis and another 1 into the prime ingress axis represents
        10<sup>50</sup> + 1.

        <pre>
<span class="card">N1 1</span>
<span class="card">N2 1</span>
<span class="card">N3 2</span>
<span class="card"></span>
<span class="card">/</span>
<span class="card">L2</span>
<span class="card">L1'</span>
<span class="card">L3</span>
<span class="card"></span>
<span class="comment">  Print the quotient.</span>
<span class="card"></span>
<span class="card">S3'</span>
<span class="card">P</span>
<span class="card"></span>
<span class="comment">  Print the remainder.</span>
<span class="card"></span>
<span class="card">S4</span>
<span class="card">P</span></pre>
      </div>

      <p>Performing the same operation twice does not require re-specifying the
      operation.

      <div class="example">
        <p>Multiply two by two, and then multiply that product by two.  Store
        the result in memory address 1.
        <pre>
<span class="card">N1 2</span>
<span class="card">N2 2</span>
<span class="card"></span>
<span class="card">*</span>
<span class="card">L1</span>
<span class="card">L2</span>
<span class="card">S1</span>
<span class="card">L1</span>
<span class="card">L2</span>
<span class="card">S1</span></pre>
      </div>

      <p>Numbers can be printed to the printer by using the <code>P</code>
      card. To remain historically accurate, the simulator does not print
      directly to standard output when it encounters a print card; instead, the
      attendant collects all printed strings and makes them available only
      after the program has terminated.

      <div class="example">
        <p>Print the sum of 123 and 456 to the printer.
        <pre>
<span class="card">N1 123</span>
<span class="card">N2 456</span>
<span class="card"></span>
<span class="card">+</span>
<span class="card">L1</span>
<span class="card">L2</span>
<span class="card">S3</span>
<span class="card">P</span></pre>
      </div>

      <p>What gives this machine its computational power is conditional
      execution. A conditional jump card checks whether the run-up lever has
      been set and either reverses or advances the card chain by a specified
      number of cards.

      <div class="example">
        <p>In this example, the Engine computes a factorial by accumulating the
        product of <em>n</em> with (<em>n</em> - 1)! iteratively. At the end of
        each iteration, the conditional jump card decides whether to perform
        another iteration of the loop or to terminate and print the result
        based on whether the run-up lever has been set.

        <pre>
<span class="comment">  Computes 6! using a loop.</span>
<span class="card"></span>
<span class="comment">  Address 0 is the current value of n.</span>
<span class="comment">  Address 1 is the accumulator for the product.</span>
<span class="comment">  Address 2 represents the constant 1.</span>
<span class="card"></span>
<span class="card">N0 6</span>
<span class="card">N1 1</span>
<span class="card">N2 1</span>
<span class="card"></span>
<span class="card">*</span>
<span class="card">L1</span>
<span class="card">L0</span>
<span class="card">S1</span>
<span class="card">-</span>
<span class="card">L0</span>
<span class="card">L2</span>
<span class="card">S0</span>
<span class="comment">   If 1 - n &lt; 0, go back 12 cards (including this one!)</span>
<span class="card">L2</span>
<span class="card">L0</span>
<span class="card">CB?12</span>
<span class="card">L1</span>
<span class="card">P</span></pre>
      </div>
    </section>

    <section id="programmatic-access">
      <h2>Programmatic access to the simulator</h2>

      <p>The sim&shy;u&shy;la&shy;tor per&shy;forms the fol&shy;low&shy;ing
      high&shy;-lev&shy;el al&shy;go&shy;rithm

      <ol>
        <li>pre&shy;pare a card chain,</li>
        <li>ask the at&shy;ten&shy;dant to load the card chain,</li>
        <li>run the En&shy;gine.</li>
      </ol>

      <p>The Attendant in&shy;ter&shy;face and
      the <code>AnalyticalEngine</code> in&shy;ter&shy;face are the most
      sig&shy;nif&shy;i&shy;cant parts of the sim&shy;u&shy;la&shy;tor
      in&shy;ter&shy;face. Once a card chain is pre&shy;pared, the
      at&shy;ten&shy;dant loads the cards into the En&shy;gine us&shy;ing the
      <code>Attendant.loadProgram()</code> method. Once the cards are
      load&shy;ed, call&shy;ing the <code>AnalyticalEngine.run()</code> method
      ex&shy;e&shy;cutes the pro&shy;gram. Any out&shy;put is
      col&shy;lect&shy;ed by the at&shy;ten&shy;dant and can be ac&shy;cessed
      via the <code>Attendant.finalReport()</code> method.

      <p>The <code>AnalyticalEngine</code> must be programmatically assembled
      before it can execute a program. The Engine needs a mill, a store, a card
      reader, etc., each of which can be set using the appropriately named
      setter methods.

      <p>The code is designed that each component can be easily reimplemented
      and replaced. For example, one might replace the default
      <code>HashMap</code>-based implementation of <code>Store</code> with one
      backed by a remote key-value data store:

      <pre class="java">package mycoolpackage;

import analyticalengine.components.Store;
import ???.redis.???;
import java.math.BigInteger;

public class RedisStore implements Store {
    public BigInteger get(long address) {
        return redis.get(address);
    }

    public BigInteger put(long address, BigInteger value) {
        redis.put(address, value);
    }

    public void reset() {
        redis.clear();
    }
}
</pre>

      <p>This new store can then be set on an <code>AnalyticalEngine</code>
      instance <code>engine</code> via <code>engine.setStore(new RedisStor())</code>.

    </section>

    <section id="copyright">
      <h2>Copyright license</h2>

      <p>Copyright 2014&ndash;2016 Jeffrey&nbsp;Finkelstein.

      <p>The code is distributed under the terms of the <abbr>GNU</abbr>
      General Public License version 3. It is derived from
      the <a href="//www.fourmilab.ch/babbage/contents.html">original code</a>
      by John&nbsp;Walker, which was
      <a href="//www.fourmilab.ch/babbage/cmdline.html">dedicated to the public
      domain</a>.

      <p>This document is distributed under the terms of the
      <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
      Creative Commons Attribution-ShareAlike 4.0 International license</a>.
    </section>

  </div>
</body>
</html>
