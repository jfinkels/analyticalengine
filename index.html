<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="Java simulation of Charles Babbage's Analytical Engine.">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Analytical Engine</title>

  <link href="https://fonts.googleapis.com/css?family=Libre+Baskerville" rel="stylesheet">
  <link rel="stylesheet" href="css/analyticalengine.css">
</head>
<body>
  <div class="container">
    <header>
      <p>Charles&nbsp;Babbage&rsquo;s
      <h1>Analytical Engine</h1>
      <p>A Java Simulation
    </header>

    <p>In the mid-1800s, Charles&nbsp;Babbage designed (but never built) a
    machine that we would today call a digital computer. On this machine model,
    Ada&nbsp;Lovelace designed the first computer program. Babbage&rsquo;s
    initial descriptions of the machine predate Alan&nbsp;Turing by about a
    hundred years. This Java simulation of the Analytical Engine will help to
    preserve the legacy of these pioneers of computing.

    <nav>
      <h2>Contents</h2>
      <ul>
        <li><a href="#hardware">Hardware overview</a></li>
        <li><a href="#preparing">Preparing the simulator</a></li>
        <li><a href="#programming">Programming the Engine</a></li>
        <li><a href="#programmatic-access">Programmatic access to the simulator</a></li>
        <li><a href="#copyright">Copyright license</a></li>
      </ul>
    </nav>

    <section id="hardware">
      <h2>Hardware overview</h2>

      <aside>
        <p>For more information on the terminology,
        see <a href="http://www.fourmilab.ch/babbage/glossary.html">this
        glossary</a>.
      </aside>

      <p>The Analytical Engine machinery is essentially the same as that of a
      (simple) modern digital computer. Here is a brief description of the
      hardware including both the old and new terminologies.

      <p>Each instruction for the machine comes on a <dfn>card</dfn> with
      holes punched in it to indicate which instruction it represents (that
      is, its &quot;opcode&quot;). A program is provided as a sequence of
      cards.

      <p>The random access memory of the machine is called
      the <dfn>store</dfn> and the arithmetic logic unit is called
      the <dfn>mill</dfn>. The mill performs arithmetic operations on
      integers, each of which is stored in a register called
      an <dfn>axis</dfn> (plural <dfn>axes</dfn>). Integers read from
      memory are stored in <dfn>ingress axes</dfn> and the result of
      arithmetic operations are stored in <dfn>egress axes</dfn>. The
      <dfn>run-up lever</dfn> is a flag that is set when an arithmetic
      operation causes an integer overflow.

      <p>The machine is controlled by an <dfn>attendant</dfn> who loads
      programs, starts and operates the machine while the program executes,
      and provides a final report showing the output of the machine. The
      machine can produce textual output via a printer as well as graphical
      output via a <dfn>curve drawing apparatus</dfn>, a device we would
      call a plotter.
    </section>

    <section id="preparing">
      <h2>Preparing the simulator</h2>

      <p>The source code for the Analytical Engine simulator is available
      from <a href="//github.com/jfinkels/analyticalengine">GitHub</a>.

      <pre class="command-line"><span class="command">git clone https://github.com/jfinkels/analyticalengine</span></pre>

      <p>This project uses <a href="//maven.apache.org/">Maven</a> for
      build management and requires Java 1.8 to compile.

      <p>To create a shell script that runs the simulator, run

      <pre class="command-line"><span class="command">mvn package appassembler:assemble</span></pre>

      <p>This produces a script that executes the simulator
      at <code>target/appassembler/bin/analyticalengine</code>. An Analytical
      Engine program stored in a file named <code>myprogram.ae</code>, for
      example, can then be executed via

      <pre class="command-line"><span class="command">target/appassembler/bin/analyticalengine myprogram.ae</span></pre>
    </section>

    <section id="programming">
      <h2>Programming the Engine</h2>

      <p>The programming language for this machine is arcane, but
      relatively similar to modern machine languages. For more information
      on the instruction set and how to write programs for this machine,
      see <a href="http://www.fourmilab.ch/babbage/cards.html">this
      website</a>.

      <div class="example">
        <p>Store the number 123 in memory location 1.
        <pre class="ae-code"><span class="card">N1 123</span></pre>
      </div>
      <div class="example">
        <p>Lines beginning with a space or a period are comments.
        <!-- A period after another instruction indicates a comment. -->
        <pre>
<span class="comment">   This program does foo and bar.</span>
<span class="card"></span>
<span class="card">N1 123</span>
<span class="card"></span>
<span class="comment">. This is another comment</span>
<span class="card"></span>
<span class="card">N2 456</span>
</pre>
      </div>
      <div class="example">
        <p>Add two numbers from memory locations 1 and 2 and store the
        result in memory location 3.
        <pre>
<span class="card">N1 123</span>
<span class="card">N2 456</span>
<span class="comment"></span>
<span class="card">+</span>
<span class="card">L1</span>
<span class="card">L2</span>
<span class="card">S3</span></pre>
        <p>The operation is automatically executed once two operands are
        loaded.
      </div>
      <div class="example">
        <p>Division can be performed on a dividend of "double width" by
        loading the lower-order digits of the dividend in the first main
        ingress axis and the higher-order digits of the dividend into the
        "prime" ingress axis. The prime axis must be loaded after the main
        axis.
        <p>The quotient of a division can be accessed from the prime egress
        axis, and the remainder from the main egress axis.
        <pre>
<span class="comment">     Compute (10^50 + 1) / 2</span>
<span class="card"></span>
<span class="card">N1 1</span>
<span class="card">N2 1</span>
<span class="card">N3 2</span>
<span class="card"></span>
<span class="card">/</span>
<span class="card">L2</span>
<span class="card">L1'</span>
<span class="card">L3</span>
<span class="card"></span>
<span classs="comment">  Print the quotient.</span>
<span class="card"></span>
<span class="card">S3'</span>
<span class="card">P</span>
<span class="card"></span>
<span classs="comment">  Print the remainder.</span>
<span class="card"></span>
<span class="card">S4</span>
<span class="card">P</span></pre>
        <p>If the quotient is too large for the main axis, the run-up lever
        is set, and the quotient and remainder will be set to 0.
      </div>
      <div class="example">
        <p>Performing the same operation twice does not require
        re-specifying the operation.
        <pre>
<span class="card">N1 2</span>
<span class="card">N2 2</span>
<span class="card"></span>
<span class="card">*</span>
<span class="card">L1</span>
<span class="card">L2</span>
<span class="card">S1</span>
<span class="card">L1</span>
<span class="card">L2</span>
<span class="card">S1</span></pre>
        <p>Memory address 1 now contains value 8.
      </div>
      <div class="example">
        <p>Print a number to the printer.
        <pre>
<span class="card">N1 123</span>
<span class="card">N2 456</span>
<span class="card"></span>
<span class="card">+</span>
<span class="card">L1</span>
<span class="card">L2</span>
<span class="card">S3</span>
<span class="card">P</span></pre>
        <p>The <code>P</code> instruction does not print directly to
        standard output; the attendant receives all printed strings and
        makes them all available at once after the program has terminated.
      </div>
      <div class="example">
        <p>Loop back to previously performed instructions, depending on
        whether the overflow (or sign change) flag has been set.
        <pre>
<span class="comment">  Computes 6! using a loop.</span>
<span class="card"></span>
<span class="comment">  Address 0 is the current value of n.</span>
<span class="comment">  Address 1 is the accumulator for the product.</span>
<span class="comment">  Address 2 represents the constant 1.</span>
<span class="card"></span>
<span class="card">N0 6</span>
<span class="card">N1 1</span>
<span class="card">N2 1</span>
<span class="card"></span>
<span class="card">*</span>
<span class="card">L1</span>
<span class="card">L0</span>
<span class="card">S1</span>
<span class="card">-</span>
<span class="card">L0</span>
<span class="card">L2</span>
<span class="card">S0</span>
<span class="comment">   If 1 - n < 0, go back 12 cards (including this one!)</span>
<span class="card">L2</span>
<span class="card">L0</span>
<span class="card">CB?12</span>
<span class="card">L1</span>
<span class="card">P</span></pre>
      </div>
    </section>

    <section id="programmatic-access">
      <h2>Programmatic access to the simulator</h2>

      <p>The simulator performs the following high-level algorithm

      <ol>
        <li>prepare a card chain,</li>
        <li>ask the attendant to load the card chain,</li>
        <li>run the Engine.</li>
      </ol>

      <p>The <code>Attendant</code> interface and the
      <code>AnalyticalEngine</code> interface are the most significant parts of
      the simulator interface. Once a card chain is prepared, the attendant
      loads the cards into the Engine using the
      <code>Attendant.loadProgram()</code> method. Once the cards are loaded,
      calling the <code>AnalyticalEngine.run()</code> method executes the
      program. Any output is collected by the attendant and can be accessed via
      the <code>Attendant.finalReport()</code> method.

      <p>The <code>AnalyticalEngine</code> must be programmatically assembled
      before it can execute a program. The Engine needs a mill, a store, a card
      reader, etc., each of which can be set using the appropriately named
      setter methods.

      <p>The code is designed that each component can be easily reimplemented
      and replaced. For example, one might replace the default
      <code>HashMap</code>-based implementation of <code>Store</code> with one
      backed by a remote key-value data store:

      <pre class="java">package mycoolpackage;

import analyticalengine.components.Store;
import ???.redis.???;
import java.math.BigInteger;

public class RedisStore implements Store {
    public BigInteger get(long address) {
        return redis.get(address);
    }

    public BigInteger put(long address, BigInteger value) {
        redis.put(address, value);
    }

    public void reset() {
        redis.clear();
    }
}
</pre>

      <p>This new store can then be set on an <code>AnalyticalEngine</code>
      instance <code>engine</code> via <code>engine.setStore(new RedisStor())</code>.

    </section>

    <section id="copyright">
      <h2>Copyright license</h2>

      <p>Copyright 2014&ndash;2016 Jeffrey&nbsp;Finkelstein.

      <p>The code is distributed under the terms of the <abbr>GNU</abbr>
      General Public License version 3. It is derived from
      the <a href="//www.fourmilab.ch/babbage/contents.html">original code</a>
      by John&nbsp;Walker, which was
      <a href="//www.fourmilab.ch/babbage/cmdline.html">dedicated to the public
      domain</a>.

      <p>This document is distributed under the terms of the
      <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
      Creative Commons Attribution-ShareAlike 4.0 International license</a>.
    </section>

  </div>
</body>
</html>
